# Feature 0002: Action Parameter Passing

## Problem Statement

The current task engine architecture has a fundamental limitation: actions cannot easily pass data to subsequent actions. This creates several issues:

1. **Complex Action Coupling**: Actions must be aware of previous action results, making them less reusable
2. **Runtime Data Access**: Actions try to access data from other actions at creation time, before execution

### Current Problem Example

```go
// Current problematic approach
func NewCleanupAgentsTask(config CleanupAgentsTaskConfig, logger *slog.Logger) *task_engine.Task {
    listAction := agent_actions.NewListAgentFilesAction(config.AgentDirectory, logger)

    // This fails - AgentFiles is empty at creation time
    var paths []string
    for _, item := range listAction.Wrapped.AgentFiles {
        paths = append(paths, item.Path)
    }

    removeAction := file.NewRemoveFilesAction(paths, logger)
    // ...
}
```

## Solution Overview

The updated task engine will support declarative parameter passing between actions **and tasks** while maintaining clean, reusable definitions. Each action and task can define its own parameter type, and the task engine handles all parameter mapping at execution time.

### Scope: Cross-Entity Parameter Passing

This system enables comprehensive data flow across the entire task engine:

#### **Intra-Task Communication**

- **Action A** executes and produces output
- **Action B** can reference Action A's output as a parameter
- **Action C** can reference both Action A and Action B outputs
- All within the same task execution context

#### **Cross-Task Communication**

- **Task 1** executes and produces output
- **Task 2** can reference Task 1's output as a parameter
- **Action** in Task 3 can reference output from Task 1 or Task 2
- **Task 4** can reference output from any combination of actions and tasks

#### **Mixed References**

- Actions can reference outputs from other tasks
- Tasks can reference outputs from individual actions
- Complex workflows can be built with data flowing between any entities

This creates a comprehensive data flow ecosystem where any entity can build upon the results of any other entity in the system.

#### Example: Three-Action Pipeline

```go
// Task: "file-processing" with three sequential actions
Actions: [
    readFileAction,      // Action A: Reads file, produces content
    transformAction,     // Action B: Uses content from Action A
    writeFileAction,     // Action C: Uses transformed content from Action B
]

// Execution flow:
// 1. readFileAction executes → content stored in TaskContext
// 2. transformAction executes with content from Action A → transformed content stored
// 3. writeFileAction executes with transformed content from Action B
```

**Yes, this system allows "task 1" containing "action a" and "action b" to utilize the result from "action a" in "action b"** - this is the core functionality the parameter passing system provides.

## Technical Architecture

### Core Changes

#### 1. Action Output Interface

- **File**: `action.go`
- **Changes**: Extend `ActionInterface` to include output methods
- **Details**: Add `GetOutput() interface{}` method to allow actions to expose their execution results
- **Integration**: Leverage existing `ResultProvider` interface for actions that produce results

#### 2. Parameter Mapping System

- **File**: `task.go`
- **Changes**: Add parameter mapping logic to `Task.Run()` method
- **Details**: Implement runtime parameter resolution before each action execution

#### 3. Action Parameter Types

- **File**: `action.go`
- **Changes**: Define parameter types and mapping interfaces
- **Details**: Create parameter structs that can reference previous action outputs

### Implementation Details

#### Phase 1: Data Layer Foundation

##### 1.1 Action Output Interface

```go
// Extend ActionInterface in action.go
type ActionInterface interface {
    BeforeExecute(ctx context.Context) error
    Execute(ctx context.Context) error
    AfterExecute(ctx context.Context) error
    GetOutput() interface{} // NEW: Return action execution results
}

// Actions can optionally implement ResultProvider for richer result handling
type ActionWithResults interface {
    ActionInterface
    ResultProvider
}
```

##### 1.2 Parameter Types

```go
// New types in action.go
type ActionParameter interface {
    Resolve(ctx context.Context, globalContext *GlobalContext) (interface{}, error)
}

type StaticParameter struct {
    Value interface{}
}

type ActionOutputParameter struct {
    ActionID string
    OutputKey string // Optional: for actions with multiple outputs
}

// Enhanced parameter for actions implementing ResultProvider
type ActionResultParameter struct {
    ActionID string
    ResultKey string // Maps to ResultProvider.GetResult() or specific output field
}

// Cross-task parameter references
type TaskOutputParameter struct {
    TaskID string
    OutputKey string // Optional: for tasks with multiple outputs
}

// Mixed entity parameter references
type EntityOutputParameter struct {
    EntityType string // "action" or "task"
    EntityID   string
    OutputKey  string // Optional: for entities with multiple outputs
}
```

##### 1.3 Global Context

```go
// New struct in task.go (renamed from TaskContext for clarity)
type GlobalContext struct {
    ActionOutputs map[string]interface{}
    ActionResults map[string]ResultProvider // For actions implementing ResultProvider
    TaskOutputs   map[string]interface{}   // For tasks that produce outputs
    TaskResults   map[string]ResultProvider // For tasks implementing ResultProvider
    mu            sync.RWMutex
}
```

#### Phase 2: Execution Engine

##### 2.1 Parameter Resolution

- **File**: `task.go`
- **Function**: `Task.resolveParameters(ctx, action, taskContext)`
- **Logic**: Resolve all parameters before action execution, replacing action references with actual values
- **ResultProvider Integration**: Check if action implements ResultProvider and store for enhanced parameter resolution

##### 2.2 Action and Task Execution Flow

- **File**: `task.go`
- **Function**: `Task.Run()` and `TaskManager.RunTask()`
- **Changes**: Add parameter resolution step before each action/task execution
- **Flow**:
  1. Execute action/task
  2. Store action output in global context (`GlobalContext.ActionOutputs`)
  3. Store action as ResultProvider if applicable (`GlobalContext.ActionResults`)
  4. Store task output in global context (`GlobalContext.TaskOutputs`)
  5. Store task as ResultProvider if applicable (`GlobalContext.TaskResults`)
  6. Resolve parameters for next action/task using accumulated global context
  7. Execute next action/task with resolved parameters
  8. Continue until all actions/tasks complete

**Key Insight**: The `GlobalContext` maintains state across the entire system, allowing any entity (action or task) to access results from any other entity (action or task) that has already executed.

#### Phase 3: Action Integration

##### 3.1 Update Existing Actions

- **Files**: All action files in `actions/` directory
- **Changes**: Implement `GetOutput()` method for each action
- **Optional Enhancement**: Implement `ResultProvider` interface for actions with rich result data
- **Examples**:
  - `docker/docker_run_action.go`: Return container ID and status
  - `file/read_file_action.go`: Return file contents
  - `docker/docker_compose_ps_action.go`: Return service list

##### 3.2 Parameter-Aware Action Constructors

- **Files**: All action constructor functions
- **Changes**: Accept `ActionParameter` types instead of concrete values
- **Example**:

```go
// Before
func NewRemoveFilesAction(paths []string, logger *slog.Logger) *Action[*RemoveFilesAction]

// After
func NewRemoveFilesAction(paths ActionParameter, logger *slog.Logger) *Action[*RemoveFilesAction]
```

## Files to Modify

### Core Engine Files

1. **`action.go`**

   - Add `GetOutput()` method to `ActionInterface`
   - Define parameter types and interfaces
   - Update `Action[T]` struct to support parameter resolution

2. **`task.go`**

   - Add `TaskContext` struct
   - Implement parameter resolution logic
   - Update `Task.Run()` method to handle parameter mapping

3. **`interface.go`**
   - Update `ActionInterface` to include output methods
   - Add parameter-related interfaces

### Action Files (All actions in `actions/` directory)

1. **`actions/docker/*.go`** - Implement `GetOutput()` methods
2. **`actions/file/*.go`** - Implement `GetOutput()` methods
3. **`actions/system/*.go`** - Implement `GetOutput()` methods
4. **`actions/utility/*.go`** - Implement `GetOutput()` methods

### Task Files

1. **`tasks/*.go`** - Update task definitions to use new parameter system

## ResultProvider Integration

### Leveraging Existing Infrastructure

The existing `ResultProvider` interface provides a natural extension point for the parameter passing system:

```go
// Existing interface from interface.go
type ResultProvider interface {
    GetResult() interface{}
    GetError() error
}

// Enhanced action interface that can optionally provide rich results
type ActionWithResults interface {
    ActionInterface
    ResultProvider
}
```

### Benefits of ResultProvider Integration

1. **Established Pattern**: The interface is already well-tested and has comprehensive mocking support
2. **Error Handling**: Actions can provide both results and error information
3. **Testing Support**: Existing `ResultProviderMock` can be used for testing parameter resolution
4. **Backward Compatibility**: Actions can implement ResultProvider without breaking existing code
5. **Rich Result Data**: Actions can return complex data structures with proper error handling

### Example Action Implementation

```go
type DockerRunAction struct {
    BaseAction
    Image         string
    RunArgs       []string
    ContainerID   string
    ExitCode      int
    Error         error
}

// Implement ActionInterface
func (a *DockerRunAction) GetOutput() interface{} {
    return map[string]interface{}{
        "containerID": a.ContainerID,
        "exitCode":    a.ExitCode,
        "success":     a.Error == nil,
    }
}

// Optionally implement ResultProvider for enhanced functionality
func (a *DockerRunAction) GetResult() interface{} {
    return a.GetOutput()
}

func (a *DockerRunAction) GetError() error {
    return a.Error
}
```

## Algorithm Details

### Parameter Resolution Algorithm

```
1. For each action in task:
   a. Resolve all parameters using TaskContext
   b. Execute action with resolved parameters
   c. Store action output in TaskContext
   d. Continue to next action
```

### Parameter Resolution Steps

```
1. Check if parameter is StaticParameter:
   - Return Value directly
2. Check if parameter is ActionOutputParameter:
   - Look up ActionID in GlobalContext.ActionOutputs
   - Extract OutputKey if specified
   - Return resolved value
3. Check if parameter is ActionResultParameter:
   - Look up ActionID in GlobalContext.ActionResults
   - Use ResultProvider.GetResult() or extract specific field
   - Return resolved value
4. Check if parameter is TaskOutputParameter:
   - Look up TaskID in GlobalContext.TaskOutputs
   - Extract OutputKey if specified
   - Return resolved value
5. Check if parameter is EntityOutputParameter:
   - Determine entity type (action or task)
   - Look up in appropriate GlobalContext map
   - Extract OutputKey if specified
   - Return resolved value
6. Handle parameter type conversion as needed
7. Return error if resolution fails
```

## Example Usage After Implementation

### Intra-Task Action Communication

The parameter passing system enables actions within the same task to share data seamlessly:

```go
func NewFileProcessingTask(config FileProcessingConfig, logger *slog.Logger) *task_engine.Task {
    return &task_engine.Task{
        ID:   "file-processing",
        Name: "Process and Transform Files",
        Actions: []engine.ActionWrapper{
            // Action A: Read source file
            file.NewReadFileAction(
                config.SourcePath,
                nil, // outputBuffer will be populated
                logger,
            ),

            // Action B: Transform content using output from Action A
            file.NewReplaceLinesAction(
                config.SourcePath,
                map[*regexp.Regexp]string{
                    regexp.MustCompile("{{content}}"):
                        ActionOutputParameter{ActionID: "read-file-source", OutputKey: "content"},
                },
                logger,
            ),

            // Action C: Write to new location with transformed content
            file.NewWriteFileAction(
                config.DestinationPath,
                nil, // content will come from previous action
                true, // overwrite
                ActionOutputParameter{ActionID: "replace-lines-action", OutputKey: "content"},
                logger,
            ),
        },
        Logger: logger,
    }
}
```

### Basic Parameter Passing

```go
func NewCleanupAgentsTask(config CleanupAgentsTaskConfig, logger *slog.Logger) *task_engine.Task {
    return &task_engine.Task{
        ID:   "cleanup-agents",
        Name: "Cleanup Agent Files",
        Actions: []engine.ActionWrapper{
            // List agent files - will produce output
            agent_actions.NewListAgentFilesAction(config.AgentDirectory, logger),

            // Remove files using output from previous action
            file.NewRemoveFilesAction(
                ActionOutputParameter{ActionID: "list-agent-files", OutputKey: "paths"},
                logger,
            ),
        },
        Logger: logger,
    }
}
```

### Enhanced ResultProvider Integration

```go
func NewDockerDeploymentTask(config DockerDeploymentConfig, logger *slog.Logger) *task_engine.Task {
    return &task_engine.Task{
        ID:   "docker-deployment",
        Name: "Docker Container Deployment",
        Actions: []engine.ActionWrapper{
            // Pull image - returns image info and any errors
            docker.NewDockerPullAction(logger, config.Images),

            // Run container using image from previous action
            docker.NewDockerRunAction(
                logger,
                ActionResultParameter{ActionID: "docker-pull-action", ResultKey: "imageName"},
                nil, // outputBuffer
                config.RunArgs...,
            ),

            // Check health using container ID from run action
            docker.NewCheckContainerHealthAction(
                logger,
                ActionResultParameter{ActionID: "docker-run-action", ResultKey: "containerID"},
                config.HealthCheckTimeout,
            ),
        },
        Logger: logger,
    }
}
```

### Cross-Task Parameter Passing

```go
// Task 1: Build and package application
func NewBuildTask(config BuildConfig, logger *slog.Logger) *task_engine.Task {
    return &task_engine.Task{
        ID:   "build-application",
        Name: "Build and Package Application",
        Actions: []engine.ActionWrapper{
            // Build actions that produce artifacts
            build.NewCompileAction(config.SourceDir, logger),
            build.NewPackageAction(config.OutputDir, logger),
        },
        Logger: logger,
    }
}

// Task 2: Deploy using artifacts from Task 1
func NewDeployTask(config DeployConfig, logger *slog.Logger) *task_engine.Task {
    return &task_engine.Task{
        ID:   "deploy-application",
        Name: "Deploy Application",
        Actions: []engine.ActionWrapper{
            // Deploy action using package path from build task
            deploy.NewDeployAction(
                TaskOutputParameter{TaskID: "build-application", OutputKey: "packagePath"},
                config.Environment,
                logger,
            ),
        },
        Logger: logger,
    }
}

// Task 3: Monitor deployment using results from both previous tasks
func NewMonitorTask(config MonitorConfig, logger *slog.Logger) *task_engine.Task {
    return &task_engine.Task{
        ID:   "monitor-deployment",
        Name: "Monitor Deployment Health",
        Actions: []engine.ActionWrapper{
            // Monitor using deployment ID from deploy task
            monitor.NewHealthCheckAction(
                TaskOutputParameter{TaskID: "deploy-application", OutputKey: "deploymentID"},
                config.CheckInterval,
                logger,
            ),
        },
        Logger: logger,
    }
}
```

## Ergonomics and Usability Design

### Design Principles

The parameter passing system is designed with these ergonomic principles:

1. **Explicit Over Implicit**: All parameter references must be explicit, no magic or hidden dependencies
2. **Consistent Syntax**: Uniform parameter syntax across all entity types
3. **Compile-Time Validation**: Catch parameter errors before runtime
4. **Clear Naming**: Parameter types have descriptive names that indicate their purpose
5. **Fail Fast**: Parameter resolution errors are caught early with helpful error messages

### Parameter Syntax Design

#### **Consistent Naming Convention**

```go
// All parameter types follow the pattern: [Entity]OutputParameter
ActionOutputParameter{ActionID: "action-name", OutputKey: "key"}
TaskOutputParameter{TaskID: "task-name", OutputKey: "key"}
EntityOutputParameter{EntityType: "action", EntityID: "name", OutputKey: "key"}
```

#### **Required vs Optional Fields**

```go
// ActionID/TaskID is always required
ActionOutputParameter{ActionID: "must-have"} // Valid

// OutputKey is optional - if omitted, returns entire output
ActionOutputParameter{ActionID: "action-name"} // Returns full output
ActionOutputParameter{ActionID: "action-name", OutputKey: "specific-field"} // Returns specific field
```

### Error Prevention Mechanisms

#### **1. Compile-Time Type Safety**

```go
// Parameter types are strongly typed
type ActionOutputParameter struct {
    ActionID  string // Required
    OutputKey string // Optional
}

// This prevents common mistakes:
// ❌ Wrong: ActionOutputParameter{ActionID: 123} // Compile error
// ✅ Correct: ActionOutputParameter{ActionID: "action-name"}
```

#### **2. Validation at Construction**

```go
// Parameter constructors validate inputs
func NewActionOutputParameter(actionID string, outputKey string) ActionOutputParameter {
    if actionID == "" {
        panic("ActionID cannot be empty")
    }
    return ActionOutputParameter{ActionID: actionID, OutputKey: outputKey}
}

// Usage:
// ❌ Wrong: ActionOutputParameter{ActionID: ""} // Panic with clear message
// ✅ Correct: NewActionOutputParameter("action-name", "output-key")
```

#### **3. Runtime Validation**

```go
// Parameter resolution validates at runtime
func (p ActionOutputParameter) Resolve(ctx context.Context, globalContext *GlobalContext) (interface{}, error) {
    if p.ActionID == "" {
        return nil, fmt.Errorf("ActionOutputParameter: ActionID cannot be empty")
    }

    output, exists := globalContext.ActionOutputs[p.ActionID]
    if !exists {
        return nil, fmt.Errorf("ActionOutputParameter: action '%s' not found in context", p.ActionID)
    }

    if p.OutputKey != "" {
        // Validate OutputKey exists in output
        if outputMap, ok := output.(map[string]interface{}); ok {
            if value, exists := outputMap[p.OutputKey]; exists {
                return value, nil
            }
            return nil, fmt.Errorf("ActionOutputParameter: output key '%s' not found in action '%s'", p.OutputKey, p.ActionID)
        }
        return nil, fmt.Errorf("ActionOutputParameter: action '%s' output is not a map, cannot extract key '%s'", p.ActionID, p.OutputKey)
    }

    return output, nil
}
```

### Common Pitfalls and Prevention

#### **1. Circular Dependencies**

```go
// ❌ Problematic: Action A references Action B, but Action B references Action A
Actions: [
    actionA, // References actionB output
    actionB, // References actionA output
]

// ✅ Solution: Task engine detects and prevents circular references
func (t *Task) validateNoCircularDependencies() error {
    // Implementation detects cycles in parameter references
    return nil
}
```

#### **2. Missing Entity References**

```go
// ❌ Problematic: Reference to non-existent action
ActionOutputParameter{ActionID: "non-existent-action"}

// ✅ Solution: Clear error message at runtime
// Error: "ActionOutputParameter: action 'non-existent-action' not found in context"
```

#### **3. Type Mismatches**

```go
// ❌ Problematic: Expecting string but getting int
ActionOutputParameter{ActionID: "action-name", OutputKey: "count"}
// If action outputs: {"count": 42} (int), but action expects string

// ✅ Solution: Type validation and conversion helpers
func (p ActionOutputParameter) ResolveAsString(ctx context.Context, globalContext *GlobalContext) (string, error) {
    value, err := p.Resolve(ctx, globalContext)
    if err != nil {
        return "", err
    }

    switch v := value.(type) {
    case string:
        return v, nil
    case int:
        return strconv.Itoa(v), nil
    default:
        return "", fmt.Errorf("cannot convert %T to string", value)
    }
}
```

### Helper Functions for Common Patterns

#### **1. Type-Safe Parameter Creation**

```go
// Helper functions for common parameter patterns
func ActionOutput(actionID string) ActionOutputParameter {
    return ActionOutputParameter{ActionID: actionID}
}

func ActionOutputField(actionID, field string) ActionOutputParameter {
    return ActionOutputParameter{ActionID: actionID, OutputKey: field}
}

func TaskOutput(taskID string) TaskOutputParameter {
    return TaskOutputParameter{TaskID: taskID}
}

func TaskOutputField(taskID, field string) TaskOutputParameter {
    return TaskOutputParameter{TaskID: taskID, OutputKey: field}
}

// Usage becomes more readable:
// Before: ActionOutputParameter{ActionID: "read-file", OutputKey: "content"}
// After:  ActionOutputField("read-file", "content")
```

#### **2. Parameter Validation Helpers**

```go
// Validate parameters before task execution
func (t *Task) ValidateParameters() error {
    for i, action := range t.Actions {
        if err := t.validateActionParameters(action, i); err != nil {
            return fmt.Errorf("action %d (%s): %w", i, action.GetName(), err)
        }
    }
    return nil
}

func (t *Task) validateActionParameters(action ActionWrapper, index int) error {
    // Implementation validates all parameters can be resolved
    return nil
}
```

### Best Practices for Downstream Clients

#### **1. Naming Conventions**

```go
// ✅ Good: Use descriptive, consistent names
Actions: [
    file.NewReadFileAction("config.yaml", nil, logger),           // ID: "read-config"
    yaml.NewParseYamlAction(nil, logger),                       // ID: "parse-yaml"
    config.NewValidateConfigAction(nil, logger),                 // ID: "validate-config"
]

// Reference with clear names
ActionOutputParameter{ActionID: "read-config", OutputKey: "content"}
ActionOutputParameter{ActionID: "parse-yaml", OutputKey: "parsed"}
ActionOutputParameter{ActionID: "validate-config", OutputKey: "isValid"}
```

#### **2. Output Structure Design**

```go
// ✅ Good: Consistent output structure across actions
func (a *ReadFileAction) GetOutput() interface{} {
    return map[string]interface{}{
        "content":    a.Content,
        "fileSize":   a.FileSize,
        "readTime":   a.ReadTime,
        "success":    a.Error == nil,
    }
}

// ❌ Avoid: Inconsistent or unclear output structures
func (a *ReadFileAction) GetOutput() interface{} {
    return a.Content // Just returns raw content, no metadata
}
```

#### **3. Parameter Validation**

```go
// ✅ Good: Validate parameters early in task creation
func NewFileProcessingTask(config FileConfig, logger *slog.Logger) *task_engine.Task {
    task := &task_engine.Task{
        // ... task configuration
    }

    // Validate parameters before returning
    if err := task.ValidateParameters(); err != nil {
        logger.Error("Invalid task parameters", "error", err)
        panic(fmt.Sprintf("Task validation failed: %v", err))
    }

    return task
}
```

#### **4. Error Handling in Parameter Resolution**

```go
// ✅ Good: Handle parameter resolution errors gracefully
func (a *ProcessFileAction) Execute(ctx context.Context) error {
    content, err := a.ContentParam.Resolve(ctx, a.globalContext)
    if err != nil {
        return fmt.Errorf("failed to resolve content parameter: %w", err)
    }

    // Type assertion with error handling
    contentStr, ok := content.(string)
    if !ok {
        return fmt.Errorf("content parameter is not a string, got %T", content)
    }

    // Process content...
    return nil
}
```

#### **5. Documentation and Examples**

```go
// ✅ Good: Document expected parameter types and outputs
type ReadFileAction struct {
    BaseAction
    FilePath string
    Content  string
    Error    error
}

// GetOutput returns a map with the following structure:
// {
//   "content": string,    // File contents
//   "fileSize": int64,    // File size in bytes
//   "readTime": time.Time, // When file was read
//   "success": bool       // Whether read was successful
// }
func (a *ReadFileAction) GetOutput() interface{} {
    return map[string]interface{}{
        "content":  a.Content,
        "fileSize": a.FileSize,
        "readTime": a.ReadTime,
        "success":  a.Error == nil,
    }
}
```

### Common Usage Patterns

#### **1. Simple Data Flow**

```go
// Read file → Process content → Write result
Actions: [
    file.NewReadFileAction("input.txt", nil, logger),
    process.NewTransformAction(
        ActionOutputParameter{ActionID: "read-file", OutputKey: "content"},
        "uppercase",
        logger,
    ),
    file.NewWriteFileAction(
        "output.txt",
        ActionOutputParameter{ActionID: "transform", OutputKey: "result"},
        true,
        logger,
    ),
]
```

#### **2. Conditional Processing**

```go
// Read file → Check if valid → Process if valid
Actions: [
    file.NewReadFileAction("data.json", nil, logger),
    json.NewValidateAction(
        ActionOutputParameter{ActionID: "read-file", OutputKey: "content"},
        logger,
    ),
    process.NewConditionalAction(
        ActionOutputParameter{ActionID: "validate", OutputKey: "isValid"},
        ActionOutputParameter{ActionID: "read-file", OutputKey: "content"},
        logger,
    ),
]
```

#### **3. Cross-Task Workflows**

```go
// Build → Deploy → Monitor
// Task 1: Build
func NewBuildTask(config BuildConfig, logger *slog.Logger) *task_engine.Task {
    return &task_engine.Task{
        ID: "build-app",
        Actions: [/* build actions */],
        Logger: logger,
    }
}

// Task 2: Deploy (uses build output)
func NewDeployTask(config DeployConfig, logger *slog.Logger) *task_engine.Task {
    return &task_engine.Task{
        ID: "deploy-app",
        Actions: []engine.ActionWrapper{
            deploy.NewDeployAction(
                TaskOutputParameter{TaskID: "build-app", OutputKey: "packagePath"},
                config.Environment,
                logger,
            ),
        },
        Logger: logger,
    }
}
```

## Benefits

1. **Decoupled Actions**: Actions no longer need to know about each other
2. **Runtime Data Flow**: Parameter resolution happens at execution time
3. **Reusable Actions**: Actions can be used in different task contexts
4. **Type Safety**: Parameter types are defined and validated
5. **Cleaner Task Definitions**: Tasks become more declarative and easier to understand
6. **Leverages Existing Infrastructure**: Integrates with established `ResultProvider` interface
7. **Enhanced Result Handling**: Actions can provide rich result data with error information
8. **Intra-Task Data Flow**: Actions within the same task can build upon each other's results
9. **Cross-Task Data Flow**: Tasks can reference outputs from other tasks
10. **Mixed Entity References**: Actions can reference task outputs, tasks can reference action outputs
11. **Comprehensive Workflows**: Build complex multi-task pipelines with data flowing between any entities
12. **Pipeline Execution**: Create sophisticated workflows where each step feeds into the next across the entire system
13. **Intuitive Ergonomics**: Clear, consistent parameter syntax that's hard to misuse
14. **Compile-Time Safety**: Parameter validation and type checking to catch errors early

## Migration Strategy

1. **Phase 1**: Implement core parameter system without breaking existing code
2. **Phase 2**: Update action constructors to accept both old and new parameter types
3. **Phase 3**: Gradually migrate existing tasks to use new parameter system
4. **Phase 4**: Remove deprecated parameter passing methods
5. **Phase 5**: Implement ergonomic improvements for ID and output key management

### Phase 5: Ergonomic Improvements

#### 5.1 Instance-Based ID Fetching

**Problem**: Currently, users must manually specify string IDs for actions and tasks, which is error-prone and creates maintenance overhead.

**Solution**: Auto-generated IDs with optional override capability.

```go
// Enhanced ActionWrapper interface
type ActionWrapper interface {
    ActionInterface
    GetID() string
    SetID(string) // Optional: allow manual override
    GetName() string
}

// Enhanced Action struct
type Action[T ActionInterface] struct {
    Wrapped T
    ID      string
    Name    string
    // ... existing fields
}

// Auto-generate ID if not provided
func NewAction[T ActionInterface](wrapped T, name string, id ...string) *Action[T] {
    actionID := name
    if len(id) > 0 && id[0] != "" {
        actionID = id[0]
    }

    return &Action[T]{
        Wrapped: wrapped,
        ID:      actionID,
        Name:    name,
    }
}

// Usage becomes much simpler:
// Before: file.NewReadFileAction("config.yaml", nil, logger) // Must manually track ID
// After:  file.NewReadFileAction("config.yaml", nil, logger) // ID auto-generated as "read-file"
```

**Benefits**:

- No more manual string management for IDs
- Automatic ID generation based on action names
- Optional manual override when needed
- Reduced chance of ID conflicts or typos

#### 5.2 Type-Safe Output Key Management

**Problem**: Output keys are currently string-based, making them error-prone and not type-safe.

**Solution**: Generic approach with type constraints and compile-time validation.

```go
// Generic constraint for output types
type OutputType interface {
    // Marker interface - any struct can implement this
    // We'll use reflection or code generation to validate the structure
}

// Constraint for actions that produce specific output types
type ActionWithOutput[T OutputType] interface {
    ActionInterface
    GetOutput() T
}

// Enhanced Action struct with generic output type
type Action[T ActionInterface, O OutputType] struct {
    Wrapped T
    ID      string
    Name    string
    Output  O
    // ... existing fields
}

// Type-safe output key references
type TypedOutputKey[T OutputType] struct {
    ActionID string
    Key      string
}

// Compile-time validation of output keys
func (k TypedOutputKey[T]) Validate() error {
    // Use reflection to validate that Key exists in T
    t := reflect.TypeOf((*T)(nil)).Elem()
    if t.Kind() == reflect.Struct {
        _, exists := t.FieldByName(k.Key)
        if !exists {
            return fmt.Errorf("field '%s' does not exist in output type %T", k.Key, (*T)(nil))
        }
    }
    return nil
}

// Usage with type safety:
type FileReadOutput struct {
    Content  string
    FileSize int64
    ReadTime time.Time
    Success  bool
}

// Action with typed output
readAction := file.NewReadFileAction[FileReadOutput]("config.yaml", nil, logger)

// Type-safe output key reference
contentKey := TypedOutputKey[FileReadOutput]{
    ActionID: readAction.GetID(),
    Key:      "Content", // Compile-time validation that this field exists
}

// Parameter using typed key
param := ActionOutputParameter{
    ActionID:  readAction.GetID(),
    OutputKey: "Content", // Type-safe reference
}
```

**Alternative Approach**: Code generation for compile-time validation.

```go
//go:generate go run github.com/vektra/mockery/v2 --name ActionInterface --output ./mocks

// Generated code ensures output keys are valid at compile time
type GeneratedOutputKeys struct {
    ReadFileAction struct {
        Content  string
        FileSize int64
        ReadTime time.Time
        Success  bool
    }
    DockerRunAction struct {
        ContainerID string
        ExitCode    int
        Success     bool
    }
}

// Usage with generated keys
contentKey := ActionOutputParameter{
    ActionID:  readAction.GetID(),
    OutputKey: GeneratedOutputKeys.ReadFileAction.Content, // Compile-time safe
}
```

**Benefits**:

- Compile-time validation of output keys
- Type safety prevents runtime errors
- Better IDE support with autocomplete
- Refactoring safety (renaming fields updates all references)

#### 5.3 Implementation Strategy for Phase 5

**Step 1**: Extend Action Interface

```go
// Update action.go
type ActionInterface interface {
    BeforeExecute(ctx context.Context) error
    Execute(ctx context.Context) error
    AfterExecute(ctx context.Context) error
    GetOutput() interface{}
    GetID() string        // NEW
    SetID(string)         // NEW
    GetName() string      // NEW
}
```

**Step 2**: Update Action Constructor Pattern

```go
// New pattern for all action constructors
func NewReadFileAction[T OutputType](filePath string, outputBuffer T, logger *slog.Logger, id ...string) *Action[*ReadFileAction, T] {
    actionID := "read-file"
    if len(id) > 0 && id[0] != "" {
        actionID = id[0]
    }

    return &Action[*ReadFileAction, T]{
        Wrapped: &ReadFileAction{
            FilePath: filePath,
            Output:   outputBuffer,
            Logger:   logger,
        },
        ID:   actionID,
        Name: "Read File",
    }
}
```

**Step 3**: Update Task Definition Pattern

```go
// New task definition pattern
func NewFileProcessingTask(config FileConfig, logger *slog.Logger) *task_engine.Task {
    readAction := file.NewReadFileAction[FileReadOutput]("input.txt", nil, logger)
    processAction := process.NewTransformAction[ProcessedOutput](
        ActionOutputParameter{
            ActionID:  readAction.GetID(), // Auto-generated ID
            OutputKey: "Content",          // Type-safe key
        },
        "uppercase",
        logger,
    )

    return &task_engine.Task{
        ID:      "file-processing",
        Name:    "Process and Transform Files",
        Actions: []engine.ActionWrapper{readAction, processAction},
        Logger:  logger,
    }
}
```

**Step 4**: Backward Compatibility

```go
// Maintain backward compatibility during transition
func NewReadFileAction(filePath string, outputBuffer interface{}, logger *slog.Logger) *Action[*ReadFileAction] {
    // Legacy constructor - delegates to new generic constructor
    return NewReadFileAction[interface{}](filePath, outputBuffer, logger)
}
```

#### 5.4 Migration Benefits

**For Developers**:

- No more manual ID string management
- Compile-time validation of output keys
- Better IDE support and autocomplete
- Reduced chance of runtime errors

**For Maintainers**:

- Easier refactoring (renaming fields updates all references)
- Better code organization and type safety
- Reduced debugging time from ID/key mismatches

**For Users**:

- More intuitive API
- Better error messages at compile time
- Consistent naming conventions

## Testing Strategy

1. **Unit Tests**: Test parameter resolution logic in isolation
2. **Integration Tests**: Test parameter passing between actions in real tasks
3. **Backward Compatibility Tests**: Ensure existing tasks continue to work
4. **Performance Tests**: Measure impact of parameter resolution on task execution time
