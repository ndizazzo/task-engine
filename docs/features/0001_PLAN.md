# Task Manager Testability Improvements

## Overview

This document outlines the plan to improve the testability of the task-engine library. The current implementation has several testing challenges that limit downstream clients' ability to write effective unit tests.

## Current Issues

### 1. **Concrete Type Dependency**

- Downstream clients expect concrete `*task_engine.TaskManager` types
- Makes it impossible to use mocks in tests
- Forces tests to use real task manager instances

### 2. **Limited Interface**

- The external `task-engine` module doesn't provide a proper interface for mocking
- No abstraction layer between business logic and task execution
- Tight coupling between components

### 3. **Stateful Operations**

- Task manager maintains internal state that's difficult to control in tests
- No way to reset state between test runs
- Hard to verify internal state changes

### 4. **No Result Retrieval (address this later)**

- Difficult to assert expected outcomes in tests
- No standardized way to handle task results
- Tasks don't provide a clean way to retrieve results for verification (this will be adressed in another update)

The goal is to provide a nice way for downstream clients to more easily write unit tests for their applications implementing task-engine.

## Recommended Improvements

### 1. Create Interface Wrapper

```go
// interface.go
package task_engine

import (
    "context"
    "log/slog"
)

// TaskManagerInterface defines the contract for task management
type TaskManagerInterface interface {
    AddTask(task *Task) error
    RunTask(taskID string) error
    StopTask(taskID string) error
    StopAllTasks()
    GetRunningTasks() []string
    IsTaskRunning(taskID string) bool
}

// TaskInterface defines the contract for individual tasks
type TaskInterface interface {
    GetID() string
    GetName() string
    Run(ctx context.Context) error
    GetCompletedTasks() int
    GetTotalTime() time.Duration
}

// ResultProvider interface for tasks that produce results
type ResultProvider interface {
    GetResult() interface{}
    GetError() error
}
```

### 2. Implement a Testable Task Manager

```go
// testable_manager.go
package task_engine

import (
    "log/slog"
    "sync"
    "time"
)

// TestableTaskManager provides enhanced testing capabilities
type TestableTaskManager struct {
    *TaskManager
    mu sync.RWMutex

    // Testing hooks
    onTaskAdded   func(*Task)
    onTaskStarted func(string)
    onTaskCompleted func(string, error)

    // Result storage for testing
    taskResults map[string]interface{}
    taskErrors  map[string]error
}

// NewTestableTaskManager creates a testable task manager
func NewTestableTaskManager(logger *slog.Logger) *TestableTaskManager {
    return &TestableTaskManager{
        TaskManager: NewTaskManager(logger),
        taskResults: make(map[string]interface{}),
        taskErrors:  make(map[string]error),
    }
}

// SetTaskAddedHook sets a callback for when tasks are added
func (tm *TestableTaskManager) SetTaskAddedHook(hook func(*Task)) {
    tm.mu.Lock()
    defer tm.mu.Unlock()
    tm.onTaskAdded = hook
}

// SetTaskStartedHook sets a callback for when tasks start
func (tm *TestableTaskManager) SetTaskStartedHook(hook func(string)) {
    tm.mu.Lock()
    defer tm.mu.Unlock()
    tm.onTaskStarted = hook
}

// SetTaskCompletedHook sets a callback for when tasks complete
func (tm *TestableTaskManager) SetTaskCompletedHook(hook func(string, error)) {
    tm.mu.Lock()
    defer tm.mu.Unlock()
    tm.onTaskCompleted = hook
}

// OverrideTaskResult allows tests to set expected results
func (tm *TestableTaskManager) OverrideTaskResult(taskID string, result interface{}) {
    tm.mu.Lock()
    defer tm.mu.Unlock()
    tm.taskResults[taskID] = result
}

// OverrideTaskError allows tests to set expected errors
func (tm *TestableTaskManager) OverrideTaskError(taskID string, err error) {
    tm.mu.Lock()
    defer tm.mu.Unlock()
    tm.taskErrors[taskID] = err
}

// GetTaskResult retrieves the result for a specific task
func (tm *TestableTaskManager) GetTaskResult(taskID string) (interface{}, bool) {
    tm.mu.RLock()
    defer tm.mu.RUnlock()
    result, exists := tm.taskResults[taskID]
    return result, exists
}

// GetTaskError retrieves the error for a specific task
func (tm *TestableTaskManager) GetTaskError(taskID string) (error, bool) {
    tm.mu.RLock()
    defer tm.mu.RUnlock()
    err, exists := tm.taskErrors[taskID]
    return err, exists
}

// ClearTestData clears all test-related data
func (tm *TestableTaskManager) ClearTestData() {
    tm.mu.Lock()
    defer tm.mu.Unlock()
    tm.taskResults = make(map[string]interface{})
    tm.taskErrors = make(map[string]error)
}
```

### 3. Enhanced Mock Implementation

```go
// mocks/task_manager_mock.go
package mocks

import (
    "sync"
    "github.com/stretchr/testify/mock"
    task_engine "github.com/ndizazzo/task-engine"
)

// EnhancedTaskManagerMock provides comprehensive mocking capabilities
type EnhancedTaskManagerMock struct {
    mock.Mock
    mu sync.RWMutex

    // State tracking
    tasks map[string]*task_engine.Task
    runningTasks map[string]bool
    taskResults map[string]interface{}
    taskErrors map[string]error

    // Call tracking
    addTaskCalls []*task_engine.Task
    runTaskCalls []string
    stopTaskCalls []string
}

// NewEnhancedTaskManagerMock creates a new enhanced mock
func NewEnhancedTaskManagerMock() *EnhancedTaskManagerMock {
    return &EnhancedTaskManagerMock{
        tasks: make(map[string]*task_engine.Task),
        runningTasks: make(map[string]bool),
        taskResults: make(map[string]interface{}),
        taskErrors: make(map[string]error),
    }
}

// AddTask mocks AddTask with state tracking
func (m *EnhancedTaskManagerMock) AddTask(task *task_engine.Task) error {
    args := m.Called(task)

    m.mu.Lock()
    defer m.mu.Unlock()

    if task != nil {
        m.tasks[task.ID] = task
        m.addTaskCalls = append(m.addTaskCalls, task)
    }

    return args.Error(0)
}

// RunTask mocks RunTask with state tracking
func (m *EnhancedTaskManagerMock) RunTask(taskID string) error {
    args := m.Called(taskID)

    m.mu.Lock()
    defer m.mu.Unlock()

    m.runningTasks[taskID] = true
    m.runTaskCalls = append(m.runTaskCalls, taskID)

    return args.Error(0)
}

// StopTask mocks StopTask with state tracking
func (m *EnhancedTaskManagerMock) StopTask(taskID string) error {
    args := m.Called(taskID)

    m.mu.Lock()
    defer m.mu.Unlock()

    delete(m.runningTasks, taskID)
    m.stopTaskCalls = append(m.stopTaskCalls, taskID)

    return args.Error(0)
}

// StopAllTasks mocks StopAllTasks
func (m *EnhancedTaskManagerMock) StopAllTasks() {
    m.Called()

    m.mu.Lock()
    defer m.mu.Unlock()

    m.runningTasks = make(map[string]bool)
}

// GetRunningTasks returns the current running tasks
func (m *EnhancedTaskManagerMock) GetRunningTasks() []string {
    args := m.Called()

    m.mu.RLock()
    defer m.mu.RUnlock()

    var running []string
    for taskID, running := range m.runningTasks {
        if running {
            running = append(running, taskID)
        }
    }

    if args.Get(0) != nil {
        return args.Get(0).([]string)
    }
    return running
}

// IsTaskRunning checks if a specific task is running
func (m *EnhancedTaskManagerMock) IsTaskRunning(taskID string) bool {
    args := m.Called(taskID)

    m.mu.RLock()
    defer m.mu.RUnlock()

    if args.Get(0) != nil {
        return args.Bool(0)
    }
    return m.runningTasks[taskID]
}

// SetTaskResult allows tests to set expected results
func (m *EnhancedTaskManagerMock) SetTaskResult(taskID string, result interface{}) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.taskResults[taskID] = result
}

// SetTaskError allows tests to set expected errors
func (m *EnhancedTaskManagerMock) SetTaskError(taskID string, err error) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.taskErrors[taskID] = err
}

// GetAddedTasks returns all tasks that were added
func (m *EnhancedTaskManagerMock) GetAddedTasks() []*task_engine.Task {
    m.mu.RLock()
    defer m.mu.RUnlock()
    return append([]*task_engine.Task{}, m.addTaskCalls...)
}

// GetRunTaskCalls returns all RunTask calls
func (m *EnhancedTaskManagerMock) GetRunTaskCalls() []string {
    m.mu.RLock()
    defer m.mu.RUnlock()
    return append([]string{}, m.runTaskCalls...)
}

// ClearHistory clears all call history
func (m *EnhancedTaskManagerMock) ClearHistory() {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.addTaskCalls = nil
    m.runTaskCalls = nil
    m.stopTaskCalls = nil
}
```

### 4. Example Usage in Downstream Projects

```go
// Example: How downstream projects can use the interface
type UpdateManager struct {
    // ... other fields ...
    taskManager task_engine.TaskManagerInterface // Use interface instead of concrete type
    // ... other fields ...
}

// Constructor accepts interface
func NewUpdateManager(
    config Config,
    display display.Manager,
    taskManager task_engine.TaskManagerInterface, // Accept interface
    logger *slog.Logger,
) *UpdateManager {
    // ... implementation ...
}
```

## Benefits of These Improvements

### 1. **Easier Mocking**

- Tests can use the enhanced mock without type conflicts
- No more concrete type dependency issues
- Clean separation between test and production code

### 2. **Better State Control**

- Tests can set expected results and errors
- Predictable behavior in test scenarios
- Easy to test edge cases and error conditions

### 3. **Call Verification**

- Tests can verify exactly what methods were called with what arguments
- Comprehensive assertion capabilities
- Better debugging when tests fail

### 4. **Test Isolation**

- Tests can run in isolation without affecting each other
- No shared state between test runs
- Consistent test behavior

### 5. **Flexibility**

- Tests can choose between real implementation and mocks
- Easy to switch between different testing strategies
- Support for both unit and integration tests

### 6. **Maintainability**

- Interface-based design makes the code more maintainable
- Easier to refactor and modify
- Better adherence to SOLID principles

## Implementation Priority

### **High Priority (Immediate)**

1. Create the interface wrapper (`internal/task_engine/interface.go`)
2. Update existing tests to use the new interface

### **Medium Priority**

1. Implement the enhanced mock (`tests/mocks/task_manager_mock.go`)
2. Add comprehensive test coverage for task manager interactions

### **Low Priority**

1. Implement the testable task manager (`internal/task_engine/testable_manager.go`)
2. Add advanced testing features like hooks and callbacks
3. Performance testing and benchmarking capabilities

## Migration Strategy

### Phase 1: Interface Introduction

- Create interfaces without breaking existing code
- Migrate components to use interfaces

### Phase 2: Mock Implementation

- Implement enhanced mocks
- Update existing tests to use new mocks
- Remove dependency on concrete types in tests

### Phase 3: Advanced Features

- Add testable task manager implementation
- Implement advanced testing capabilities
- Performance optimization and benchmarking

## Conclusion

These improvements will significantly enhance the testability of the task manager while maintaining backward compatibility and improving the overall architecture. The interface-based approach will make the code more maintainable and easier to test, leading to higher quality and more reliable software.

The phased implementation approach ensures that we can gradually migrate without disrupting existing functionality, while the enhanced mocking capabilities will make our tests more robust and easier to maintain.
